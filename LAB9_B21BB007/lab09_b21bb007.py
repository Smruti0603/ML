# -*- coding: utf-8 -*-
"""LAB09_B21BB007.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zKtL_wIFs_kAXRNj3WYTkmcKcl3z6tqp
"""

import numpy as np
import pandas as pd

from pandas import DataFrame


from sklearn import linear_model, svm
from sklearn import datasets

from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.metrics import accuracy_score


data = pd.read_csv("banknote.csv")
data

data.columns = [ "variance of Wavelet Transformed image " , "skewness of Wavelet Transformed image" , "curtosis of Wavelet Transformed image " 
                , "entropy of image" , "classes"]

"""**QUE 1**"""

#Removing Null/NaN values.
data = data.dropna(axis=0)

X = data.iloc[: , 0:4]

#
from sklearn.preprocessing import MinMaxScaler
minmax = MinMaxScaler()
minmax.fit(X)
minmaxdata = minmax.transform(X)

df_data = pd.DataFrame(minmaxdata)

df_data

df_data.columns = [ "variance of Wavelet Transformed image " , "skewness of Wavelet Transformed image" , "curtosis of Wavelet Transformed image " 
                , "entropy of image" ]
df_data

#Training the model
x = df_data
y = data.iloc[: , -1]


from sklearn.model_selection import train_test_split

x_main ,x_test , y_main , y_test  = train_test_split( x , y , test_size = 0.2 )

x_train , x_val , y_train , y_val = train_test_split(x_main , y_main , test_size = 0.1 )

"""**Que 2**"""

perceptron_clf = linear_model.Perceptron(max_iter=500)
perceptron_clf.fit(x_train, y_train)

perceptron_clf.score(x_test, y_test)

kf = KFold( n_splits = 5)

for train_index , test_index in kf.split(df_data):
  print(train_index , test_index)

for train_index , test_index in kf.split(df_data):
  X_train , X_test ,  Y_train , Y_test = df_data.values[train_index] , df_data.values[test_index] , data.classes[train_index] , data.classes[test_index]
  perceptron_clf.fit(X_train, Y_train)
  print(perceptron_clf.score(X_test, Y_test))

"""**QUE 4**

"""

for i in range(5 , 11):
  svm_clf = svm.SVC(C=5, kernel='rbf')
  svm_clf.fit(X_train, Y_train)
  print(svm_clf.score(X_test, Y_test))

"""**QUE 3**"""

#Training the model
x = df_data.values
y = data.iloc[: , -1]


from sklearn.model_selection import train_test_split

x_main ,x_test , y_main , y_test  = train_test_split( x , y , test_size = 0.2 )

x_train , x_val , y_train , y_val = train_test_split(x_main , y_main , test_size = 0.1 )

class MPerceprton:

  def __init__(self , learning_rate= 0.1 , n_iterations = 500 ):
    self.lr = learning_rate 
    self.epochs = n_iterations
    self.weights = None
    self.bias = None 


  def fit(self , x , y):

    self.weights = np.zeros(x.shape[1]) 
    self.bias = 0

    for epoch in range(self.epochs):

      for i in range(x.shape[0]) :

        y_predict = self.ypre(np.dot(self.weights , x[i]) + self.bias )

        self.weights =  self.weights + self.lr*( y[i] - y_predict)*x[i]
        self.bias = self.bias +  self.lr*( y[i] - y_predict)



    print(self.weights)
    print(self.bias)


  def ypre(self , ypre ):
    if ypre >0 :
      return 1

    else :
      return 0


  def predict(self , x):

    y_pred = []
    for i in  range(x.shape[0]):
      np.dot(self.weights ,x[i])

      y_pred.append(self.ypre(np.dot(self.weights , x[i]) + self.bias ))

    return np.array(y_pred)S

clf = MPerceprton()

clf.fit(x , y)

ypred = clf.predict(x_test)

print(accuracy_score(y_test , y_pred) )